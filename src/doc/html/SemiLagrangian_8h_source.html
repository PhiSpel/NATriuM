<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NATriuM: /mnt/fdrive/akraem3m/workspace/NATriuM/src/library/natrium/advection/SemiLagrangian.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>/mnt/fdrive/akraem3m/workspace/NATriuM/src/library/natrium/advection/SemiLagrangian.h</h1><a href="SemiLagrangian_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00008"></a>00008 <span class="preprocessor">#ifndef SEMILAGRANGIAN_H_</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#define SEMILAGRANGIAN_H_</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;array&gt;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;deal.II/grid/tria.h&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;deal.II/fe/fe_dgq.h&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;deal.II/dofs/dof_handler.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;deal.II/lac/sparse_matrix.h&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;deal.II/fe/fe_update_flags.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;deal.II/lac/block_sparsity_pattern.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;deal.II/base/quadrature_lib.h&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="AdvectionOperator_8h.html" title="Abstract class for spatial part of the Advection Operator e_i * dx_i f.">AdvectionOperator.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;../problemdescription/BoundaryCollection.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;../utilities/BasicNames.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;../utilities/NATriuMException.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;../utilities/Timing.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;../utilities/Logging.h&quot;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="keyword">namespace </span>natrium {
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">/* forward declaration */</span>
<a name="l00033"></a>00033 <span class="keyword">class </span>Stencil;
<a name="l00034"></a>00034 
<a name="l00038"></a><a class="code" href="classnatrium_1_1SemiLagrangianException.html">00038</a> <span class="keyword">class </span><a class="code" href="classnatrium_1_1SemiLagrangianException.html" title="Exception class for SemiLagrangian advection operator.">SemiLagrangianException</a>: <span class="keyword">public</span> <a class="code" href="classnatrium_1_1NATriuMException.html" title="Exception class for CFDSolver.">NATriuMException</a> {
<a name="l00039"></a>00039 <span class="keyword">private</span>:
<a name="l00040"></a>00040         std::string message;
<a name="l00041"></a>00041 <span class="keyword">public</span>:
<a name="l00042"></a>00042         <a class="code" href="classnatrium_1_1SemiLagrangianException.html" title="Exception class for SemiLagrangian advection operator.">SemiLagrangianException</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg) :
<a name="l00043"></a>00043                         <a class="code" href="classnatrium_1_1NATriuMException.html" title="Exception class for CFDSolver.">NATriuMException</a>(msg), message(msg) {
<a name="l00044"></a>00044         }
<a name="l00045"></a>00045         <a class="code" href="classnatrium_1_1SemiLagrangianException.html" title="Exception class for SemiLagrangian advection operator.">SemiLagrangianException</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; msg) :
<a name="l00046"></a>00046                         <a class="code" href="classnatrium_1_1NATriuMException.html" title="Exception class for CFDSolver.">NATriuMException</a>(msg), message(msg) {
<a name="l00047"></a>00047         }
<a name="l00048"></a>00048         ~<a class="code" href="classnatrium_1_1SemiLagrangianException.html" title="Exception class for SemiLagrangian advection operator.">SemiLagrangianException</a>() <span class="keywordflow">throw</span> () {
<a name="l00049"></a>00049         }
<a name="l00050"></a>00050         <span class="keyword">const</span> <span class="keywordtype">char</span> *what() <span class="keyword">const</span> <span class="keywordflow">throw</span> () {
<a name="l00051"></a>00051                 <span class="keywordflow">return</span> this-&gt;message.c_str();
<a name="l00052"></a>00052         }
<a name="l00053"></a>00053 };
<a name="l00054"></a>00054 
<a name="l00058"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html">00058</a> <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> dim&gt; <span class="keyword">class </span><a class="code" href="classnatrium_1_1SemiLagrangian.html" title="This class solves the linear advection equations by a semi-Lagrangian scheme.">SemiLagrangian</a>: <span class="keyword">public</span> <a class="code" href="classnatrium_1_1AdvectionOperator.html" title="Abstract class for spatial part of the Advection Operator e_i * dx_i f.">AdvectionOperator</a>&lt;dim&gt; {
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keyword">private</span>:
<a name="l00061"></a>00061 
<a name="l00063"></a>00063         boost::shared_ptr&lt;Mesh&lt;dim&gt; &gt; m_mesh;
<a name="l00064"></a>00064 
<a name="l00066"></a>00066         boost::shared_ptr&lt;BoundaryCollection&lt;dim&gt; &gt; m_boundaries;
<a name="l00067"></a>00067 
<a name="l00069"></a>00069         boost::shared_ptr&lt;dealii::QGaussLobatto&lt;dim&gt; &gt; m_quadrature;
<a name="l00070"></a>00070 
<a name="l00072"></a>00072         boost::shared_ptr&lt;dealii::QGaussLobatto&lt;dim - 1&gt; &gt; m_faceQuadrature;
<a name="l00073"></a>00073 
<a name="l00075"></a>00075         boost::shared_ptr&lt;dealii::FE_DGQArbitraryNodes&lt;dim&gt; &gt; m_fe;
<a name="l00076"></a>00076 
<a name="l00078"></a>00078         boost::shared_ptr&lt;dealii::DoFHandler&lt;dim&gt; &gt; m_doFHandler;
<a name="l00079"></a>00079 
<a name="l00081"></a>00081         std::vector&lt;std::vector&lt;dealii::TrilinosWrappers::SparsityPattern&gt; &gt; m_sparsityPattern;
<a name="l00082"></a>00082 
<a name="l00084"></a>00084         <span class="keyword">const</span> dealii::MappingQ&lt;dim&gt; m_mapping;
<a name="l00085"></a>00085 
<a name="l00087"></a>00087         distributed_sparse_block_matrix m_systemMatrix;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089         distributed_block_vector m_systemVector;
<a name="l00090"></a>00090 
<a name="l00092"></a>00092         boost::shared_ptr&lt;Stencil&gt; m_stencil;
<a name="l00093"></a>00093 
<a name="l00096"></a>00096         std::map&lt;size_t, size_t&gt; m_celldof_to_q_index;
<a name="l00097"></a>00097 
<a name="l00100"></a>00100         vector&lt;std::map&lt;size_t, size_t&gt; &gt; m_facedof_to_q_index;
<a name="l00101"></a>00101 
<a name="l00103"></a>00103         vector&lt;std::map&lt;size_t, size_t&gt; &gt; m_q_index_to_facedof;
<a name="l00104"></a>00104 
<a name="l00106"></a>00106         <span class="keywordtype">size_t</span> m_orderOfFiniteElement;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         <span class="comment">// time step size</span>
<a name="l00109"></a>00109         <span class="keywordtype">double</span> m_deltaT;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         <span class="comment">// locally owned degrees of freedom (for MPI parallelization)</span>
<a name="l00112"></a>00112         dealii::IndexSet m_locallyOwnedDofs;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         <span class="comment">// locally relevant degrees of freedom (i.e. ghost layer cells)</span>
<a name="l00115"></a>00115         dealii::IndexSet m_locallyRelevantDofs;
<a name="l00116"></a>00116 
<a name="l00120"></a>00120         <span class="keywordtype">void</span> fillSparseObject(<span class="keywordtype">bool</span> sparsity_pattern = <span class="keyword">false</span>);
<a name="l00121"></a>00121 
<a name="l00125"></a>00125         <span class="keywordtype">void</span> updateSparsityPattern();
<a name="l00126"></a>00126 
<a name="l00131"></a>00131         std::map&lt;size_t, size_t&gt; map_celldofs_to_q_index() <span class="keyword">const</span>;
<a name="l00132"></a>00132 
<a name="l00137"></a>00137         vector&lt;std::map&lt;size_t, size_t&gt; &gt; map_facedofs_to_q_index() <span class="keyword">const</span>;
<a name="l00138"></a>00138 
<a name="l00143"></a>00143         vector&lt;std::map&lt;size_t, size_t&gt; &gt; map_q_index_to_facedofs() <span class="keyword">const</span>;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keyword">public</span>:
<a name="l00146"></a>00146 
<a name="l00147"></a><a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathDestination.html">00147</a>         <span class="keyword">struct </span><a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathDestination.html">LagrangianPathDestination</a> {
<a name="l00148"></a>00148                 <span class="keywordtype">size_t</span> index;
<a name="l00149"></a>00149                 <span class="keywordtype">size_t</span> direction; <span class="comment">// in case of a boundary: the outgoing direction</span>
<a name="l00150"></a>00150                 <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathDestination.html">LagrangianPathDestination</a>(<span class="keywordtype">size_t</span> i, <span class="keywordtype">size_t</span> alpha) :
<a name="l00151"></a>00151                                 index(i),  direction(alpha) {
<a name="l00152"></a>00152                 }
<a name="l00153"></a>00153                 <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathDestination.html">LagrangianPathDestination</a>(<span class="keyword">const</span> <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathDestination.html">LagrangianPathDestination</a>&amp; other):
<a name="l00154"></a>00154                         index(other.index), direction(other.direction){
<a name="l00155"></a>00155                 }
<a name="l00156"></a>00156         };
<a name="l00157"></a>00157 
<a name="l00158"></a><a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathTracker.html">00158</a>         <span class="keyword">struct </span><a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathTracker.html">LagrangianPathTracker</a> {
<a name="l00159"></a>00159                 <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathTracker.html">LagrangianPathTracker</a>(<span class="keywordtype">size_t</span> dof, <span class="keywordtype">size_t</span> a, <span class="keywordtype">size_t</span> b, <span class="keyword">const</span> dealii::Point&lt;dim&gt;&amp; x,
<a name="l00160"></a>00160                                 <span class="keyword">const</span> dealii::Point&lt;dim&gt;&amp; current_point,
<a name="l00161"></a>00161                                 <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator current_cell) :
<a name="l00162"></a>00162                                         destination(dof, a), beta(b), departurePoint(x), currentPoint(
<a name="l00163"></a>00163                                                 current_point), currentCell(current_cell) {
<a name="l00164"></a>00164 
<a name="l00165"></a>00165                 }
<a name="l00166"></a>00166                 <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathTracker.html">LagrangianPathTracker</a>(<a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathDestination.html">LagrangianPathDestination</a>&amp; dest, <span class="keywordtype">size_t</span> b, <span class="keyword">const</span> dealii::Point&lt;dim&gt;&amp; x,
<a name="l00167"></a>00167                                 <span class="keyword">const</span> dealii::Point&lt;dim&gt;&amp; current_point,
<a name="l00168"></a>00168                                 <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator current_cell) :
<a name="l00169"></a>00169                                 destination(dest), beta(b), departurePoint(x), currentPoint(
<a name="l00170"></a>00170                                                 current_point), currentCell(current_cell) {
<a name="l00171"></a>00171 
<a name="l00172"></a>00172                 }
<a name="l00173"></a>00173                 <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathTracker.html">LagrangianPathTracker</a>(<span class="keyword">const</span> <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathTracker.html">LagrangianPathTracker</a>&amp; other) :
<a name="l00174"></a>00174                                 destination(other.destination), beta(
<a name="l00175"></a>00175                                                 other.beta), departurePoint(other.departurePoint), currentPoint(
<a name="l00176"></a>00176                                                 other.currentPoint), currentCell(other.currentCell) {
<a name="l00177"></a>00177                 }
<a name="l00178"></a>00178                 <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathTracker.html">LagrangianPathTracker</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathTracker.html">LagrangianPathTracker</a>&amp; other) {
<a name="l00179"></a>00179                         destination = other.destination;
<a name="l00180"></a>00180                         beta = other.beta;
<a name="l00181"></a>00181                         departurePoint = other.departurePoint;
<a name="l00182"></a>00182                         currentPoint = other.currentPoint;
<a name="l00183"></a>00183                         currentCell = other.currentCell;
<a name="l00184"></a>00184                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00185"></a>00185                 }
<a name="l00186"></a>00186                 <a class="code" href="structnatrium_1_1SemiLagrangian_1_1LagrangianPathDestination.html">LagrangianPathDestination</a> destination; <span class="comment">// global degree of freedom at destination (includes direction)</span>
<a name="l00187"></a>00187                 <span class="keywordtype">size_t</span> beta; <span class="comment">// current directions (later: direction of departure degree of freedom (across boundary))</span>
<a name="l00188"></a>00188                 dealii::Point&lt;dim&gt; departurePoint; <span class="comment">// Lagrangian departure point x^(t-dt)</span>
<a name="l00189"></a>00189                 dealii::Point&lt;dim&gt; currentPoint; <span class="comment">// Current point x^(t-(dt-timeLeft))</span>
<a name="l00190"></a>00190                 <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator currentCell; <span class="comment">// cell of currentPoint</span>
<a name="l00191"></a>00191         };
<a name="l00192"></a>00192 
<a name="l00196"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#a0f63be1763c4063ccdf2ff4bee7a3456">00196</a>         <span class="keyword">typedef</span> std::vector&lt;LagrangianPathTracker&gt; <a class="code" href="classnatrium_1_1SemiLagrangian.html#a0f63be1763c4063ccdf2ff4bee7a3456" title="A list that stores cell-specific information for assembly.">DeparturePointList</a>;
<a name="l00197"></a>00197 
<a name="l00201"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#a8a801296be3b37837a347342f32b2d57">00201</a>         <span class="keyword">typedef</span> std::vector&lt;typename dealii::DoFHandler&lt;dim&gt;::cell_iterator&gt; <a class="code" href="classnatrium_1_1SemiLagrangian.html#a8a801296be3b37837a347342f32b2d57" title="List of neighbors.">Neighborhood</a>;
<a name="l00202"></a>00202 
<a name="l00204"></a>00204 
<a name="l00211"></a>00211         <a class="code" href="classnatrium_1_1SemiLagrangian.html#ae6ef291c9cd0579ebb5889b271d64123" title="constructor">SemiLagrangian</a>(boost::shared_ptr&lt;Mesh&lt;dim&gt; &gt; triangulation,
<a name="l00212"></a>00212                         boost::shared_ptr&lt;<a class="code" href="classnatrium_1_1BoundaryCollection.html" title="The BoundaryCollection class is a container for all boundaries of a flow domain....">BoundaryCollection&lt;dim&gt;</a> &gt; boundaries,
<a name="l00213"></a>00213                         <span class="keywordtype">size_t</span> orderOfFiniteElement, boost::shared_ptr&lt;Stencil&gt; stencil,
<a name="l00214"></a>00214                         <span class="keywordtype">double</span> delta_t);
<a name="l00215"></a>00215 
<a name="l00217"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#a6c0ebcd2055e6608cc6f280a89ea43a3">00217</a>         <span class="keyword">virtual</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#a6c0ebcd2055e6608cc6f280a89ea43a3" title="destructor">~SemiLagrangian</a>() {
<a name="l00218"></a>00218                 m_doFHandler-&gt;clear();
<a name="l00219"></a>00219         }
<a name="l00220"></a>00220         ;
<a name="l00221"></a>00221 
<a name="l00228"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#a1e41b66518f92c75135b2873a39160ff">00228</a>         <span class="keywordtype">bool</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#a1e41b66518f92c75135b2873a39160ff" title="Checks if a cell is already in the neighborhood list.">isCellInNeighborhood</a>(
<a name="l00229"></a>00229                         <span class="keyword">const</span> <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::cell_accessor&amp; cell,
<a name="l00230"></a>00230                         <span class="keyword">const</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#a8a801296be3b37837a347342f32b2d57" title="List of neighbors.">Neighborhood</a>&amp; neighborhood) {
<a name="l00231"></a>00231                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; neighborhood.size(); i++) {
<a name="l00232"></a>00232                         <span class="keywordflow">if</span> (cell.id() == neighborhood.at(i)-&gt;id()) {
<a name="l00233"></a>00233                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00234"></a>00234                         }
<a name="l00235"></a>00235                 }
<a name="l00236"></a>00236                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00237"></a>00237         }
<a name="l00238"></a>00238 
<a name="l00246"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#aac0394a8292810788e983909b2de4355">00246</a>         <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::cell_iterator <a class="code" href="classnatrium_1_1SemiLagrangian.html#aac0394a8292810788e983909b2de4355" title="get i-th neighbor of a cell, incorporating periodic boundaries">getNeighbor</a>(
<a name="l00247"></a>00247                         <span class="keyword">const</span> <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator&amp; cell,
<a name="l00248"></a>00248                         <span class="keywordtype">size_t</span> i) {
<a name="l00249"></a>00249                 <span class="comment">// cell at periodic boundary</span>
<a name="l00250"></a>00250                 <span class="keywordflow">if</span> (cell-&gt;face(i)-&gt;at_boundary()) {
<a name="l00251"></a>00251                         <span class="keywordtype">size_t</span> boundaryIndicator = cell-&gt;face(i)-&gt;boundary_id();
<a name="l00252"></a>00252                         <span class="keywordflow">if</span> (m_boundaries-&gt;isPeriodic(boundaryIndicator)) {
<a name="l00253"></a>00253                                 <span class="keyword">const</span> boost::shared_ptr&lt;PeriodicBoundary&lt;dim&gt; &gt;&amp; periodicBoundary =
<a name="l00254"></a>00254                                                 m_boundaries-&gt;getPeriodicBoundary(boundaryIndicator);
<a name="l00255"></a>00255                                 assert(periodicBoundary-&gt;isFaceInBoundary(cell, i));
<a name="l00256"></a>00256                                 <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::cell_iterator neighborCell;
<a name="l00257"></a>00257                                 periodicBoundary-&gt;getOppositeCellAtPeriodicBoundary(cell,
<a name="l00258"></a>00258                                                 neighborCell);
<a name="l00259"></a>00259                                 <span class="keywordflow">return</span> neighborCell;
<a name="l00260"></a>00260                         } <span class="keywordflow">else</span> {
<a name="l00261"></a>00261                                 <span class="keywordflow">return</span> cell-&gt;get_dof_handler().end();
<a name="l00262"></a>00262                         }
<a name="l00263"></a>00263                 }
<a name="l00264"></a>00264                 <span class="comment">// cell not at periodic boundary</span>
<a name="l00265"></a>00265                 <span class="keywordflow">return</span> cell-&gt;neighbor(i);
<a name="l00266"></a>00266         }
<a name="l00267"></a>00267 
<a name="l00275"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#ab6d5f8d666330d8f229ee727985592b8">00275</a>         <span class="keywordtype">void</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#ab6d5f8d666330d8f229ee727985592b8" title="fill the neighborhood list">getNeighborhood</a>(
<a name="l00276"></a>00276                         <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator&amp; cell,
<a name="l00277"></a>00277                         <a class="code" href="classnatrium_1_1SemiLagrangian.html#a8a801296be3b37837a347342f32b2d57" title="List of neighbors.">Neighborhood</a>&amp; neighborhood, <span class="keywordtype">size_t</span> n_shells = 1) {
<a name="l00278"></a>00278                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> faces_per_cell = 2 * dim;
<a name="l00279"></a>00279                 neighborhood.clear();
<a name="l00280"></a>00280                 vector &lt; std::array&lt;size_t, faces_per_cell&gt; &gt; visited_faces;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282                 <span class="comment">// add self</span>
<a name="l00283"></a>00283                 neighborhood.push_back(cell);
<a name="l00284"></a>00284                 visited_faces.push_back(std::array&lt;size_t, faces_per_cell&gt;());
<a name="l00285"></a>00285                 <span class="comment">// as the neighborhood gets extended every time a new neighbor is added</span>
<a name="l00286"></a>00286                 <span class="comment">// this loop runs over all cells (therefor we have to have a break)</span>
<a name="l00287"></a>00287                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; neighborhood.size(); c++) {
<a name="l00288"></a>00288                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; faces_per_cell; i++) {
<a name="l00289"></a>00289                                 <span class="comment">// TODO check the shells over cell orientation rather than face id</span>
<a name="l00290"></a>00290                                 <span class="comment">// The face-id test is risky for arbitrary meshes</span>
<a name="l00291"></a>00291                                 <span class="keywordflow">if</span> (visited_faces.at(c).at(i) &gt;= n_shells) {
<a name="l00292"></a>00292                                         <span class="keywordflow">continue</span>;
<a name="l00293"></a>00293                                 }
<a name="l00294"></a>00294                                 <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::cell_iterator n = <a class="code" href="classnatrium_1_1SemiLagrangian.html#aac0394a8292810788e983909b2de4355" title="get i-th neighbor of a cell, incorporating periodic boundaries">getNeighbor</a>(
<a name="l00295"></a>00295                                                 neighborhood.at(c), i);
<a name="l00296"></a>00296                                 <span class="keywordflow">if</span> (n == cell-&gt;get_dof_handler().end()) {
<a name="l00297"></a>00297                                         <span class="keywordflow">continue</span>;
<a name="l00298"></a>00298                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-&gt;is_artificial()) {
<a name="l00299"></a>00299                                         <span class="keywordflow">continue</span>;
<a name="l00300"></a>00300                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classnatrium_1_1SemiLagrangian.html#a1e41b66518f92c75135b2873a39160ff" title="Checks if a cell is already in the neighborhood list.">isCellInNeighborhood</a>(*n, neighborhood)) {
<a name="l00301"></a>00301                                         <span class="keywordflow">continue</span>;
<a name="l00302"></a>00302                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-&gt;active() or n-&gt;is_ghost()) {
<a name="l00303"></a>00303                                         std::array &lt; size_t, faces_per_cell &gt; v(visited_faces.at(c));
<a name="l00304"></a>00304                                         v[i]++;
<a name="l00305"></a>00305                                         visited_faces.push_back(v);
<a name="l00306"></a>00306                                         neighborhood.push_back(
<a name="l00307"></a>00307                                                         <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator(
<a name="l00308"></a>00308                                                                         n));
<a name="l00309"></a>00309                                         <span class="keywordflow">continue</span>;
<a name="l00310"></a>00310                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-&gt;has_children()) {
<a name="l00311"></a>00311                                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; n-&gt;n_children(); j++) {
<a name="l00312"></a>00312                                                 assert(n-&gt;child(j)-&gt;active());
<a name="l00313"></a>00313                                                 <span class="keywordflow">if</span> (<a class="code" href="classnatrium_1_1SemiLagrangian.html#a1e41b66518f92c75135b2873a39160ff" title="Checks if a cell is already in the neighborhood list.">isCellInNeighborhood</a>(*(n-&gt;child(j)),
<a name="l00314"></a>00314                                                                 neighborhood)) {
<a name="l00315"></a>00315                                                         <span class="keywordflow">continue</span>;
<a name="l00316"></a>00316                                                 }
<a name="l00317"></a>00317                                                 std::array &lt; size_t, faces_per_cell
<a name="l00318"></a>00318                                                                 &gt; v(visited_faces.at(c));
<a name="l00319"></a>00319                                                 v[i]++;
<a name="l00320"></a>00320                                                 visited_faces.push_back(v);
<a name="l00321"></a>00321                                                 neighborhood.push_back(
<a name="l00322"></a>00322                                                                 <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator(
<a name="l00323"></a>00323                                                                                 n-&gt;child(j)));
<a name="l00324"></a>00324                                                 <span class="keywordflow">continue</span>;
<a name="l00325"></a>00325                                         }
<a name="l00326"></a>00326                                 }
<a name="l00327"></a>00327                         }
<a name="l00328"></a>00328                 }
<a name="l00329"></a>00329         } <span class="comment">/* getNeighborhood */</span>
<a name="l00330"></a>00330 
<a name="l00337"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#a9db13229770025b4c0461d8e4ff4ee50">00337</a>         <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator <a class="code" href="classnatrium_1_1SemiLagrangian.html#a9db13229770025b4c0461d8e4ff4ee50" title="recursively search a point in neighborhood, until is found">recursivelySearchInNeighborhood</a>(
<a name="l00338"></a>00338                         <span class="keyword">const</span> dealii::Point&lt;dim&gt;&amp; p,
<a name="l00339"></a>00339                         <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator&amp; cell) {
<a name="l00340"></a>00340                 <a class="code" href="classnatrium_1_1SemiLagrangian.html#a8a801296be3b37837a347342f32b2d57" title="List of neighbors.">Neighborhood</a> neighborhood;
<a name="l00341"></a>00341                 <span class="comment">// add self</span>
<a name="l00342"></a>00342                 neighborhood.push_back(cell);
<a name="l00343"></a>00343                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; neighborhood.size(); c++) {
<a name="l00344"></a>00344                         <span class="keywordflow">if</span> (neighborhood.at(c)-&gt;point_inside(p)) {
<a name="l00345"></a>00345                                 <span class="keywordflow">return</span> neighborhood.at(c);
<a name="l00346"></a>00346                         }
<a name="l00347"></a>00347                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; dealii::GeometryInfo&lt;dim&gt;::faces_per_cell;
<a name="l00348"></a>00348                                         i++) {
<a name="l00349"></a>00349                                 <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::cell_iterator n = <a class="code" href="classnatrium_1_1SemiLagrangian.html#aac0394a8292810788e983909b2de4355" title="get i-th neighbor of a cell, incorporating periodic boundaries">getNeighbor</a>(
<a name="l00350"></a>00350                                                 neighborhood.at(c), i);
<a name="l00351"></a>00351                                 <span class="keywordflow">if</span> (n == cell-&gt;get_dof_handler().end()) {
<a name="l00352"></a>00352                                         <span class="keywordflow">continue</span>;
<a name="l00353"></a>00353                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-&gt;is_artificial()) {
<a name="l00354"></a>00354                                         <span class="keywordflow">continue</span>;
<a name="l00355"></a>00355                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classnatrium_1_1SemiLagrangian.html#a1e41b66518f92c75135b2873a39160ff" title="Checks if a cell is already in the neighborhood list.">isCellInNeighborhood</a>(*n, neighborhood)) {
<a name="l00356"></a>00356                                         <span class="keywordflow">continue</span>;
<a name="l00357"></a>00357                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-&gt;active() or n-&gt;is_ghost()) {
<a name="l00358"></a>00358                                         neighborhood.push_back(
<a name="l00359"></a>00359                                                         <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator(
<a name="l00360"></a>00360                                                                         n));
<a name="l00361"></a>00361                                         <span class="keywordflow">continue</span>;
<a name="l00362"></a>00362                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-&gt;has_children()) {
<a name="l00363"></a>00363                                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; n-&gt;n_children(); j++) {
<a name="l00364"></a>00364                                                 assert(n-&gt;child(j)-&gt;active());
<a name="l00365"></a>00365                                                 <span class="keywordflow">if</span> (<a class="code" href="classnatrium_1_1SemiLagrangian.html#a1e41b66518f92c75135b2873a39160ff" title="Checks if a cell is already in the neighborhood list.">isCellInNeighborhood</a>(*(n-&gt;child(j)),
<a name="l00366"></a>00366                                                                 neighborhood)) {
<a name="l00367"></a>00367                                                         <span class="keywordflow">continue</span>;
<a name="l00368"></a>00368                                                 }
<a name="l00369"></a>00369                                                 neighborhood.push_back(
<a name="l00370"></a>00370                                                                 <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator(
<a name="l00371"></a>00371                                                                                 n-&gt;child(j)));
<a name="l00372"></a>00372                                                 <span class="keywordflow">continue</span>;
<a name="l00373"></a>00373                                         }
<a name="l00374"></a>00374                                 }
<a name="l00375"></a>00375                         }
<a name="l00376"></a>00376                 }
<a name="l00377"></a>00377                 <span class="keywordflow">return</span> cell-&gt;get_dof_handler().end();
<a name="l00378"></a>00378         } <span class="comment">/* recursivelySearchInNeighborhood */</span>
<a name="l00379"></a>00379 
<a name="l00390"></a>00390         <span class="keywordtype">int</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#a3b096afb85f7ea3782e03ba36b973088" title="Determines which face is crossed first, when moving from one point inside the cell...">faceCrossedFirst</a>(
<a name="l00391"></a>00391                         <span class="keyword">const</span> <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator&amp; cell,
<a name="l00392"></a>00392                         <span class="keyword">const</span> dealii::Point&lt;dim&gt;&amp; p_inside,
<a name="l00393"></a>00393                         <span class="keyword">const</span> dealii::Point&lt;dim&gt;&amp; p_outside, dealii::Point&lt;dim&gt;&amp; p_boundary,
<a name="l00394"></a>00394                         <span class="keywordtype">double</span>* lambda, <span class="keywordtype">size_t</span>* child_id);
<a name="l00395"></a>00395 
<a name="l00404"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#a108742ef40b532cb9e1e26384dafec94">00404</a>         <span class="keywordtype">void</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#a108742ef40b532cb9e1e26384dafec94" title="Calculates the shape values for arbitrary points.">shapeFunctionValue</a>(<span class="keyword">const</span> <span class="keyword">typename</span> dealii::DoFHandler&lt;dim&gt;::active_cell_iterator&amp; cell,
<a name="l00405"></a>00405                         <span class="keyword">const</span> std::vector&lt;dealii::Point&lt;dim&gt; &gt;&amp; points,
<a name="l00406"></a>00406                         std::vector&lt;std::vector&lt;double&gt; &gt;&amp;values) {
<a name="l00407"></a>00407 
<a name="l00408"></a>00408                 <span class="comment">//TimerOutput::Scope timer_section(Timing::getTimer(), &quot;Assembly: evaluate function&quot;);</span>
<a name="l00409"></a>00409 
<a name="l00410"></a>00410                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> n_dofs_per_cell = cell-&gt;get_fe().n_dofs_per_cell();
<a name="l00411"></a>00411                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> n_points = points.size();
<a name="l00412"></a>00412                 assert(n_points &gt; 0);
<a name="l00413"></a>00413                 assert(values.size() == n_points);
<a name="l00414"></a>00414 
<a name="l00415"></a>00415                 <span class="comment">// clear values</span>
<a name="l00416"></a>00416                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n_points; i++) {
<a name="l00417"></a>00417                         assert(values.at(i).size() == n_dofs_per_cell);
<a name="l00418"></a>00418                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; n_dofs_per_cell; j++) {
<a name="l00419"></a>00419                                 values[i][j] = 0;
<a name="l00420"></a>00420                         }
<a name="l00421"></a>00421                 }
<a name="l00422"></a>00422                 <span class="comment">// transform to unit points</span>
<a name="l00423"></a>00423                 std::vector&lt;dealii::Point&lt;dim&gt; &gt; unit_points;
<a name="l00424"></a>00424                 <span class="comment">//std::vector&lt;double&gt; weights (n_points, 1.0);</span>
<a name="l00425"></a>00425                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n_points; i++) {
<a name="l00426"></a>00426                         dealii::Point&lt;dim&gt; h = m_mapping.transform_real_to_unit_cell(cell, points[i]);
<a name="l00427"></a>00427                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; dim; i++) {
<a name="l00428"></a>00428                                 <span class="keywordflow">if</span> (fabs(h[i]) &lt; 1e-12) {
<a name="l00429"></a>00429                                         h[i] = 0;
<a name="l00430"></a>00430                                 }
<a name="l00431"></a>00431                                 <span class="keywordflow">if</span> (fabs(h[i] - 1) &lt; 1e-12) {
<a name="l00432"></a>00432                                         h[i] = 1;
<a name="l00433"></a>00433                                 }
<a name="l00434"></a>00434                                 assert (h[i] &lt;= 1);
<a name="l00435"></a>00435                                 assert (h[i] &gt;= 0);
<a name="l00436"></a>00436                         }
<a name="l00437"></a>00437                         unit_points.push_back(h);
<a name="l00438"></a>00438                 }
<a name="l00439"></a>00439                 <span class="comment">// Now we can find out about the points</span>
<a name="l00440"></a>00440                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n_points; i++) {
<a name="l00441"></a>00441                         dealii::Quadrature &lt; dim &gt; quad(unit_points.at(i));<span class="comment">//, weights);</span>
<a name="l00442"></a>00442                         dealii::FEValues &lt; dim
<a name="l00443"></a>00443                                         &gt; fe_v(m_mapping, cell-&gt;get_fe(), quad, dealii::update_values);
<a name="l00444"></a>00444                         fe_v.reinit(cell);
<a name="l00445"></a>00445                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; n_dofs_per_cell; j++) {
<a name="l00446"></a>00446                                 values[i][j] = fe_v.shape_value(j, 0);
<a name="l00447"></a>00447                         }
<a name="l00448"></a>00448                 }
<a name="l00449"></a>00449         }
<a name="l00450"></a>00450 
<a name="l00452"></a>00452         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#a7f08b1181db3c1d1f26ba0cac9210fbc" title="function to (re-)assemble linear system">reassemble</a>();
<a name="l00453"></a>00453 
<a name="l00454"></a>00454         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setupDoFs();
<a name="l00455"></a>00455 
<a name="l00457"></a>00457         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#abbaedf8c657aa964006a3bb193185559" title="make streaming step">stream</a>();
<a name="l00458"></a>00458 
<a name="l00460"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#ae8a21527f3ab056eab8b3b0af25a572c">00460</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> distributed_sparse_block_matrix&amp; <a class="code" href="classnatrium_1_1SemiLagrangian.html#ae8a21527f3ab056eab8b3b0af25a572c" title="get global system matrix">getSystemMatrix</a>()<span class="keyword"> const </span>{
<a name="l00461"></a>00461                 <span class="keywordflow">return</span> m_systemMatrix;
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464         <span class="keyword">virtual</span> <span class="keywordtype">void</span> mapDoFsToSupportPoints(
<a name="l00465"></a>00465                         std::map&lt;dealii::types::global_dof_index, dealii::Point&lt;dim&gt; &gt;&amp; supportPoints)<span class="keyword"> const </span>{
<a name="l00466"></a>00466                 <span class="comment">//assert(supportPoints.size() == this-&gt;getNumberOfDoFs());</span>
<a name="l00467"></a>00467                 dealii::DoFTools::map_dofs_to_support_points(m_mapping, *m_doFHandler,
<a name="l00468"></a>00468                                 supportPoints);
<a name="l00469"></a>00469         }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <span class="keyword">virtual</span> <span class="keyword">const</span> boost::shared_ptr&lt;dealii::DoFHandler&lt;dim&gt; &gt;&amp; getDoFHandler()<span class="keyword"> const </span>{
<a name="l00472"></a>00472                 <span class="keywordflow">return</span> m_doFHandler;
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         <span class="keyword">const</span> std::vector&lt;std::vector&lt;dealii::TrilinosWrappers::SparsityPattern&gt; &gt;&amp; getBlockSparsityPattern()<span class="keyword"> const </span>{
<a name="l00476"></a>00476                 <span class="keywordflow">return</span> m_sparsityPattern;
<a name="l00477"></a>00477         }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479         <span class="keyword">const</span> dealii::MappingQ&lt;dim&gt;&amp; getMapping()<span class="keyword"> const </span>{
<a name="l00480"></a>00480                 <span class="keywordflow">return</span> m_mapping;
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="keyword">virtual</span> <span class="keyword">const</span> std::map&lt;size_t, size_t&gt;&amp; getCelldofToQIndex()<span class="keyword"> const </span>{
<a name="l00484"></a>00484                 <span class="keywordflow">return</span> m_celldof_to_q_index;
<a name="l00485"></a>00485         }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         <span class="keyword">const</span> vector&lt;std::map&lt;size_t, size_t&gt; &gt;&amp; getFacedofToQIndex()<span class="keyword"> const </span>{
<a name="l00488"></a>00488                 <span class="keywordflow">return</span> m_facedof_to_q_index;
<a name="l00489"></a>00489         }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         <span class="keyword">const</span> boost::shared_ptr&lt;dealii::QGaussLobatto&lt;dim - 1&gt; &gt;&amp; getFaceQuadrature()<span class="keyword"> const </span>{
<a name="l00492"></a>00492                 <span class="keywordflow">return</span> m_faceQuadrature;
<a name="l00493"></a>00493         }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         <span class="keyword">virtual</span> <span class="keyword">const</span> boost::shared_ptr&lt;dealii::FE_DGQArbitraryNodes&lt;dim&gt; &gt;&amp; getFe()<span class="keyword"> const </span>{
<a name="l00496"></a>00496                 <span class="keywordflow">return</span> m_fe;
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> getNumberOfDoFsPerCell()<span class="keyword"> const </span>{
<a name="l00500"></a>00500                 <span class="keywordflow">return</span> m_fe-&gt;dofs_per_cell;
<a name="l00501"></a>00501         }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503         <span class="keyword">virtual</span> <span class="keyword">const</span> boost::shared_ptr&lt;dealii::QGaussLobatto&lt;dim&gt; &gt;&amp; getQuadrature()<span class="keyword"> const </span>{
<a name="l00504"></a>00504                 <span class="keywordflow">return</span> m_quadrature;
<a name="l00505"></a>00505         }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507         <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> getOrderOfFiniteElement()<span class="keyword"> const </span>{
<a name="l00508"></a>00508                 <span class="keywordflow">return</span> m_orderOfFiniteElement;
<a name="l00509"></a>00509         }
<a name="l00510"></a>00510 
<a name="l00511"></a><a class="code" href="classnatrium_1_1SemiLagrangian.html#aeb3b1dfda8a0d8fe7473716f98b12647">00511</a>         <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#aeb3b1dfda8a0d8fe7473716f98b12647" title="save matrices and status to files">getNumberOfDoFs</a>()<span class="keyword"> const </span>{
<a name="l00512"></a>00512                 <span class="keywordflow">return</span> <a class="code" href="classnatrium_1_1SemiLagrangian.html#ae8a21527f3ab056eab8b3b0af25a572c" title="get global system matrix">getSystemMatrix</a>().block(0, 0).n();
<a name="l00513"></a>00513         }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <span class="keyword">virtual</span> <span class="keyword">const</span> distributed_block_vector&amp; getSystemVector()<span class="keyword"> const </span>{
<a name="l00516"></a>00516                 <span class="keywordflow">return</span> m_systemVector;
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         <span class="keyword">const</span> dealii::IndexSet&amp; getLocallyOwnedDofs() {
<a name="l00520"></a>00520                 <span class="keywordflow">return</span> m_locallyOwnedDofs;
<a name="l00521"></a>00521         }
<a name="l00522"></a>00522         <span class="keyword">const</span> dealii::IndexSet&amp; getLocallyRelevantDofs() {
<a name="l00523"></a>00523                 <span class="keywordflow">return</span> m_locallyRelevantDofs;
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <span class="keyword">virtual</span> <span class="keyword">const</span> vector&lt;std::map&lt;size_t, size_t&gt; &gt;&amp; getQIndexToFacedof()<span class="keyword"> const </span>{
<a name="l00527"></a>00527                 <span class="keywordflow">return</span> m_q_index_to_facedof;
<a name="l00528"></a>00528         }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         <span class="keyword">virtual</span> <span class="keyword">const</span> boost::shared_ptr&lt;Mesh&lt;dim&gt; &gt;&amp; getMesh()<span class="keyword"> const </span>{
<a name="l00531"></a>00531                 <span class="keywordflow">return</span> m_mesh;
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         <span class="keyword">virtual</span> <span class="keyword">const</span> boost::shared_ptr&lt;Stencil&gt;&amp; getStencil()<span class="keyword"> const </span>{
<a name="l00535"></a>00535                 <span class="keywordflow">return</span> m_stencil;
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538         <span class="keywordtype">double</span> getDeltaT()<span class="keyword"> const </span>{
<a name="l00539"></a>00539                 <span class="keywordflow">return</span> m_deltaT;
<a name="l00540"></a>00540         }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setDeltaT(<span class="keywordtype">double</span> deltaT) {
<a name="l00543"></a>00543                 m_deltaT = deltaT;
<a name="l00544"></a>00544                 updateSparsityPattern();
<a name="l00545"></a>00545         }
<a name="l00546"></a>00546 
<a name="l00547"></a>00547         <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> memory_consumption_sparsity_pattern ()<span class="keyword"> const </span>{
<a name="l00548"></a>00548                 <span class="keywordtype">size_t</span> mem = 0;
<a name="l00549"></a>00549                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; m_sparsityPattern.size(); i++){
<a name="l00550"></a>00550                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; m_sparsityPattern.at(i).size(); j++){
<a name="l00551"></a>00551                                 mem += m_sparsityPattern.at(i).at(j).memory_consumption();
<a name="l00552"></a>00552                         }
<a name="l00553"></a>00553                 }
<a name="l00554"></a>00554                 <span class="keywordflow">return</span> mem;
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 }
<a name="l00558"></a>00558 ;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560 } <span class="comment">/* namespace natrium */</span>
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="preprocessor">#endif </span><span class="comment">/* SEMILAGRANGIAN_H_ */</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 20 Sep 2016 for NATriuM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
