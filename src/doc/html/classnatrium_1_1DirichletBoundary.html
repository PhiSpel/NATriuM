<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NATriuM: natrium::DirichletBoundary&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>natrium</b>::<a class="el" href="classnatrium_1_1DirichletBoundary.html">DirichletBoundary</a>
  </div>
</div>
<div class="contents">
<h1>natrium::DirichletBoundary&lt; dim &gt; Class Template Reference</h1><!-- doxytag: class="natrium::DirichletBoundary" --><!-- doxytag: inherits="natrium::Boundary" -->
<p>Abstract class to describe Dirichlet boundary conditions. The virtual function to be overriden is assembleBoundary. Moreover, the DoF couplings at the boundary have to be defined (see Documentation of the constructors).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DirichletBoundary_8h_source.html">DirichletBoundary.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for natrium::DirichletBoundary&lt; dim &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classnatrium_1_1DirichletBoundary.gif" usemap="#natrium::DirichletBoundary&lt; dim &gt;_map" alt=""/>
  <map id="natrium::DirichletBoundary&lt; dim &gt;_map" name="natrium::DirichletBoundary&lt; dim &gt;_map">
<area href="classnatrium_1_1Boundary.html" alt="natrium::Boundary&lt; dim &gt;" shape="rect" coords="0,0,234,24"/>
<area href="classnatrium_1_1DirichletBoundaryRhoU.html" alt="natrium::DirichletBoundaryRhoU&lt; dim &gt;" shape="rect" coords="0,112,234,136"/>
</map>
 </div>
</div>

<p><a href="classnatrium_1_1DirichletBoundary-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnatrium_1_1DirichletBoundary.html#a58366f152d702561d9d30584e2c6970b">DirichletBoundary</a> (size_t boundaryIndicator, boost::shared_ptr&lt; dealii::Function&lt; dim &gt; &gt; boundaryDensity, boost::shared_ptr&lt; dealii::Function&lt; dim &gt; &gt; boundaryVelocity, BoundaryTools::DistributionCouplingAtBoundary distribution_coupling, BoundaryTools::PointCouplingAtBoundary point_coupling)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnatrium_1_1DirichletBoundary.html#a7f0b83d5c09a113a1c9ad025704962f9">DirichletBoundary</a> (size_t boundaryIndicator, const dealii::Vector&lt; double &gt; &amp;velocity, BoundaryTools::DistributionCouplingAtBoundary distribution_coupling, BoundaryTools::PointCouplingAtBoundary point_coupling)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor assigns the <a class="el" href="classnatrium_1_1Boundary.html" title="Abstract class for the description of boundaries. Base class of PeriodicBoundary...">Boundary</a> condition with a constant fixed velocity and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho = 1 \]" src="form_34.png"/>
</p>
<p> to the boundary with the given boundary indicator.  <a href="#a7f0b83d5c09a113a1c9ad025704962f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ce674b82ca4dc5bec9e03b40e55b095"></a><!-- doxytag: member="natrium::DirichletBoundary::~DirichletBoundary" ref="a5ce674b82ca4dc5bec9e03b40e55b095" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnatrium_1_1DirichletBoundary.html#a5ce674b82ca4dc5bec9e03b40e55b095">~DirichletBoundary</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destructor <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnatrium_1_1DirichletBoundary.html#a1eaa444c487f30b0a2a284e7d9f4f92e">addToSparsityPattern</a> (dealii::TrilinosWrappers::SparsityPattern &amp;cSparse, const dealii::DoFHandler&lt; dim &gt; &amp;doFHandler) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In order to include the boundary conditions into the integration we have to expand the sparsity pattern. In concrete, we have to couple blocks at the boundary that belong to different distribution functions </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{\alpha} \]" src="form_35.png"/>
</p>
<p> and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{\beta} \]" src="form_36.png"/>
</p>
<p>. The concrete coupling depends on m_pointCoupling. If this is</p>
<ul>
<li>COUPLE_ONLY_SINGLE_POINTS: only the DoFs belonging to the same point are coupled</li>
<li>COUPLE_WHOLE_FACE: all DoFs at the face are coupled, e.g. if <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \partial_{x}f_{\beta} \]" src="form_37.png"/>
</p>
 is required to calculate <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{\alpha} \]" src="form_35.png"/>
</p>
 at the boundary. </li>
</ul>
 <a href="#a1eaa444c487f30b0a2a284e7d9f4f92e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnatrium_1_1DirichletBoundary.html#a4f6ff88796031a747cab3db1be4ac603">assembleBoundary</a> (size_t alpha, const typename dealii::DoFHandler&lt; dim &gt;::active_cell_iterator &amp;cell, size_t faceNumber, dealii::FEFaceValues&lt; dim &gt; &amp;feFaceValues, const <a class="el" href="classnatrium_1_1Stencil.html">Stencil</a> &amp;stencil, const std::map&lt; size_t, size_t &gt; &amp;q_index_to_facedof, const vector&lt; double &gt; &amp;inverseLocalMassMatrix, distributed_sparse_block_matrix &amp;systemMatrix, distributed_block_vector &amp;systemVector, bool useCentralFlux=false) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pure virtual function for the concrete assembly of the boundary. The child classes have to override this function for each specific boundary.  <a href="#a4f6ff88796031a747cab3db1be4ac603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf40e86858b87e1fca3a37a4692fcf07"></a><!-- doxytag: member="natrium::DirichletBoundary::getBoundaryIndicator" ref="abf40e86858b87e1fca3a37a4692fcf07" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getBoundaryIndicator</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a539369decad08b0b7d926347b8a40760"></a><!-- doxytag: member="natrium::DirichletBoundary::getBoundaryDensity" ref="a539369decad08b0b7d926347b8a40760" args="() const " -->
const boost::shared_ptr<br class="typebreak"/>
&lt; dealii::Function&lt; dim &gt; &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>getBoundaryDensity</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a639ded592d64c585e5956aeaa29be9aa"></a><!-- doxytag: member="natrium::DirichletBoundary::getBoundaryVelocity" ref="a639ded592d64c585e5956aeaa29be9aa" args="() const " -->
const boost::shared_ptr<br class="typebreak"/>
&lt; dealii::Function&lt; dim &gt; &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>getBoundaryVelocity</b> () const </td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b166780351261b373326b5267254ed0"></a><!-- doxytag: member="natrium::DirichletBoundary::m_distributionCoupling" ref="a9b166780351261b373326b5267254ed0" args="" -->
const <br class="typebreak"/>
BoundaryTools::DistributionCouplingAtBoundary&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_distributionCoupling</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28411a6d35cd5ddbb056fc061635092c"></a><!-- doxytag: member="natrium::DirichletBoundary::m_pointCoupling" ref="a28411a6d35cd5ddbb056fc061635092c" args="" -->
const <br class="typebreak"/>
BoundaryTools::PointCouplingAtBoundary&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_pointCoupling</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;size_t dim&gt;<br/>
 class natrium::DirichletBoundary&lt; dim &gt;</h3>

<p>Abstract class to describe Dirichlet boundary conditions. The virtual function to be overriden is assembleBoundary. Moreover, the DoF couplings at the boundary have to be defined (see Documentation of the constructors). </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a58366f152d702561d9d30584e2c6970b"></a><!-- doxytag: member="natrium::DirichletBoundary::DirichletBoundary" ref="a58366f152d702561d9d30584e2c6970b" args="(size_t boundaryIndicator, boost::shared_ptr&lt; dealii::Function&lt; dim &gt; &gt; boundaryDensity, boost::shared_ptr&lt; dealii::Function&lt; dim &gt; &gt; boundaryVelocity, BoundaryTools::DistributionCouplingAtBoundary distribution_coupling, BoundaryTools::PointCouplingAtBoundary point_coupling)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnatrium_1_1DirichletBoundary.html">natrium::DirichletBoundary</a>&lt; dim &gt;::<a class="el" href="classnatrium_1_1DirichletBoundary.html">DirichletBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>boundaryIndicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; dealii::Function&lt; dim &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>boundaryDensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; dealii::Function&lt; dim &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>boundaryVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundaryTools::DistributionCouplingAtBoundary&nbsp;</td>
          <td class="paramname"> <em>distribution_coupling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundaryTools::PointCouplingAtBoundary&nbsp;</td>
          <td class="paramname"> <em>point_coupling</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boundaryIndicator</em>&nbsp;</td><td>the boundary indicator that is assigned to the target boundary. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boundaryDensity</em>&nbsp;</td><td>A dealii::Function&lt;dim&gt; that defines the prescribed density at the boundary. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boundaryVelocity</em>&nbsp;</td><td>A dealii::Function&lt;dim&gt; that defines the prescribed velocity at the boundary. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distribution_coupling</em>&nbsp;</td><td>Indicates which distributions are coupled at the boundary. There are two possibilities:</p>
<ol type="1">
<li>\[ f_{} ] depends only on the opposite distribution function \[ f_{^{}} ]. Then this parameter has to be COUPLE_ONLY_OPPOSITE_DISTRIBUTIONS.</li>
<li>\[ f_{} ] depens on all distribution functions (e.g. when the density or velocity is used for the boundary condition (the calculated on, not the prescribed one). Then, this parameter has to be COUPLE_ALL_DISTRIBUTIONS. </li>
</ol>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point_coupling</em>&nbsp;</td><td>Indicates which DoFs are coupled at the boundary. There are two cases:</p>
<ol type="1">
<li>\[ f_{} ] depends only on the distribution functions at a given point (and possibly some other data, but no distribution functions at other points). Then, this parameter has to be COUPLE_ONLY_SINGLE_POINTS.</li>
<li>\[ f_{} ] depends on the distribution functions at other points at the face (e.g. when gradients are computed.) Then, this parameter has to be COUPLE_WHOLE_FACE. </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f0b83d5c09a113a1c9ad025704962f9"></a><!-- doxytag: member="natrium::DirichletBoundary::DirichletBoundary" ref="a7f0b83d5c09a113a1c9ad025704962f9" args="(size_t boundaryIndicator, const dealii::Vector&lt; double &gt; &amp;velocity, BoundaryTools::DistributionCouplingAtBoundary distribution_coupling, BoundaryTools::PointCouplingAtBoundary point_coupling)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnatrium_1_1DirichletBoundary.html">natrium::DirichletBoundary</a>&lt; dim &gt;::<a class="el" href="classnatrium_1_1DirichletBoundary.html">DirichletBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>boundaryIndicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dealii::Vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundaryTools::DistributionCouplingAtBoundary&nbsp;</td>
          <td class="paramname"> <em>distribution_coupling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundaryTools::PointCouplingAtBoundary&nbsp;</td>
          <td class="paramname"> <em>point_coupling</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This constructor assigns the <a class="el" href="classnatrium_1_1Boundary.html" title="Abstract class for the description of boundaries. Base class of PeriodicBoundary...">Boundary</a> condition with a constant fixed velocity and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho = 1 \]" src="form_34.png"/>
</p>
<p> to the boundary with the given boundary indicator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boundaryIndicator</em>&nbsp;</td><td>the boundary indicator that is assigned to the target boundary. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>velocity</em>&nbsp;</td><td>Constant velocity vector at the boundary. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distribution_coupling</em>&nbsp;</td><td>See previous constructor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point_coupling</em>&nbsp;</td><td>See previous constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1eaa444c487f30b0a2a284e7d9f4f92e"></a><!-- doxytag: member="natrium::DirichletBoundary::addToSparsityPattern" ref="a1eaa444c487f30b0a2a284e7d9f4f92e" args="(dealii::TrilinosWrappers::SparsityPattern &amp;cSparse, const dealii::DoFHandler&lt; dim &gt; &amp;doFHandler) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnatrium_1_1DirichletBoundary.html">natrium::DirichletBoundary</a>&lt; dim &gt;::addToSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">dealii::TrilinosWrappers::SparsityPattern &amp;&nbsp;</td>
          <td class="paramname"> <em>cSparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dealii::DoFHandler&lt; dim &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>doFHandler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In order to include the boundary conditions into the integration we have to expand the sparsity pattern. In concrete, we have to couple blocks at the boundary that belong to different distribution functions </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{\alpha} \]" src="form_35.png"/>
</p>
<p> and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{\beta} \]" src="form_36.png"/>
</p>
<p>. The concrete coupling depends on m_pointCoupling. If this is</p>
<ul>
<li>COUPLE_ONLY_SINGLE_POINTS: only the DoFs belonging to the same point are coupled</li>
<li>COUPLE_WHOLE_FACE: all DoFs at the face are coupled, e.g. if <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \partial_{x}f_{\beta} \]" src="form_37.png"/>
</p>
 is required to calculate <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{\alpha} \]" src="form_35.png"/>
</p>
 at the boundary. </li>
</ul>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in/out]</em>&nbsp;</td><td>doFHandler the DoFHandler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f6ff88796031a747cab3db1be4ac603"></a><!-- doxytag: member="natrium::DirichletBoundary::assembleBoundary" ref="a4f6ff88796031a747cab3db1be4ac603" args="(size_t alpha, const typename dealii::DoFHandler&lt; dim &gt;::active_cell_iterator &amp;cell, size_t faceNumber, dealii::FEFaceValues&lt; dim &gt; &amp;feFaceValues, const Stencil &amp;stencil, const std::map&lt; size_t, size_t &gt; &amp;q_index_to_facedof, const vector&lt; double &gt; &amp;inverseLocalMassMatrix, distributed_sparse_block_matrix &amp;systemMatrix, distributed_block_vector &amp;systemVector, bool useCentralFlux=false) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classnatrium_1_1DirichletBoundary.html">natrium::DirichletBoundary</a>&lt; dim &gt;::assembleBoundary </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename dealii::DoFHandler&lt; dim &gt;::active_cell_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>faceNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dealii::FEFaceValues&lt; dim &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>feFaceValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnatrium_1_1Stencil.html">Stencil</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; size_t, size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q_index_to_facedof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>inverseLocalMassMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distributed_sparse_block_matrix &amp;&nbsp;</td>
          <td class="paramname"> <em>systemMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distributed_block_vector &amp;&nbsp;</td>
          <td class="paramname"> <em>systemVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useCentralFlux</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pure virtual function for the concrete assembly of the boundary. The child classes have to override this function for each specific boundary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alpha</em>&nbsp;</td><td>The index of the distribution function  f_{} ] for which the boundary is constructed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cell</em>&nbsp;</td><td>The current cell (assembly is done cell-by-cell) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>faceNumber</em>&nbsp;</td><td>The current face number. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>feFaceValues</em>&nbsp;</td><td>The dealii::FEFaceValues&lt;dim&gt; object, which has to be reinitialized right at the beginning of the assembleBoundary function (it can be empty, but is passed here as a function parameter to avoid construction of a new feFaceValues object). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stencil</em>&nbsp;</td><td>The DQ stencil, which is required here to get the particle velocities. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>q_index_to_facedof</em>&nbsp;</td><td>Maps quadrature nodes to DoFs (only possible for GLL nodes) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inverseLocalMassMatrix</em>&nbsp;</td><td><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M^{-1} \]" src="form_38.png"/>
</p>
<p> is multiplied with the obtained boundary matrix at the end of the assembly. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in/out]</em>&nbsp;</td><td>systemMatrix The global system matrix which is assembled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in/out]</em>&nbsp;</td><td>systemVector The global system vector which is assembled to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>useCentralFlux</em>&nbsp;</td><td>indicates whether to use a central instead of a Lax-Friedrichs flux. Should not be used, has not been tested thoroughly and yields bad results, usually. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classnatrium_1_1DirichletBoundaryRhoU.html#a9fecb00df16c4294d9852222ddbdb4ca">natrium::DirichletBoundaryRhoU&lt; dim &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/mnt/fdrive/akraem3m/workspace/NATriuM/src/library/natrium/problemdescription/<a class="el" href="DirichletBoundary_8h_source.html">DirichletBoundary.h</a></li>
<li>/mnt/fdrive/akraem3m/workspace/NATriuM/src/library/natrium/problemdescription/DirichletBoundary.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 8 Dec 2015 for NATriuM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
