<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NATriuM: natrium::DealIIExtensions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>natrium</b>::<a class="el" href="namespacenatrium_1_1DealIIExtensions.html">DealIIExtensions</a>
  </div>
</div>
<div class="contents">
<h1>natrium::DealIIExtensions Namespace Reference</h1>
<p>some extensions to deal.ii  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3b719f221dd5d719bd58896660e6525"></a><!-- doxytag: member="natrium::DealIIExtensions::SP" ref="ae3b719f221dd5d719bd58896660e6525" args="" -->
typedef <br class="typebreak"/>
TrilinosWrappers::SparsityPattern&nbsp;</td><td class="memItemRight" valign="bottom"><b>SP</b></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9796541c82011b8b792400ebefd9c008"></a><!-- doxytag: member="natrium::DealIIExtensions::make_sparser_flux_sparsity_pattern" ref="a9796541c82011b8b792400ebefd9c008" args="(const DH &amp;dof, SparsityPattern &amp;sparsity, const ConstraintMatrix &amp;constraints, const BoundaryCollection&lt; DH::dimension &gt; &amp;boundaries=natrium::BoundaryCollection&lt; DH::dimension &gt;(), FEFaceValues&lt; DH::dimension &gt; *fe_face=NULL, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_unsigned_int)" -->
template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenatrium_1_1DealIIExtensions.html#a9796541c82011b8b792400ebefd9c008">make_sparser_flux_sparsity_pattern</a> (const DH &amp;dof, SparsityPattern &amp;sparsity, const ConstraintMatrix &amp;constraints, const <a class="el" href="classnatrium_1_1BoundaryCollection.html">BoundaryCollection</a>&lt; DH::dimension &gt; &amp;boundaries=<a class="el" href="classnatrium_1_1BoundaryCollection.html">natrium::BoundaryCollection</a>&lt; DH::dimension &gt;(), FEFaceValues&lt; DH::dimension &gt; *fe_face=NULL, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_unsigned_int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like dealii::DoFTools::make_flux_sparsity_pattern but does only create non-zero entries for the DoFs situated on faces. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bc61b539df963c21b595378f9b80f5a"></a><!-- doxytag: member="natrium::DealIIExtensions::make_sparser_flux_sparsity_pattern" ref="a4bc61b539df963c21b595378f9b80f5a" args="(const DH &amp;dof, SparsityPattern &amp;sparsity, const natrium::BoundaryCollection&lt; DH::dimension &gt; &amp;boundaries, FEFaceValues&lt; DH::dimension &gt; *fe_face)" -->
template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>make_sparser_flux_sparsity_pattern</b> (const DH &amp;dof, SparsityPattern &amp;sparsity, const <a class="el" href="classnatrium_1_1BoundaryCollection.html">natrium::BoundaryCollection</a>&lt; DH::dimension &gt; &amp;boundaries, FEFaceValues&lt; DH::dimension &gt; *fe_face)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename DH &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenatrium_1_1DealIIExtensions.html#a6bc5b9999ee7c47791ea8754f586277e">make_periodicity_map_dg</a> (const typename DH::cell_iterator &amp;cell_1, const typename identity&lt; typename DH::cell_iterator &gt;::type &amp;cell_2, size_t face_nr_1, size_t face_nr_2, PeriodicCellMap&lt; DH::dimension &gt; &amp;cell_map, const bool face_orientation, const bool face_flip, const bool face_rotation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gathers cell pairs at a periodic boundary. This function starts at the coarsest level and recursively visits the subcells of boundary cells. At the active level, cell pairs are added to the cell_map.  <a href="#a6bc5b9999ee7c47791ea8754f586277e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename DH &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenatrium_1_1DealIIExtensions.html#a02ccc2d5be9d7550b75fa196aeb71656">make_periodicity_map_dg</a> (const std::vector&lt; GridTools::PeriodicFacePair&lt; typename DH::cell_iterator &gt; &gt; &amp;periodic_faces, PeriodicCellMap&lt; DH::dimension &gt; &amp;cell_map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">High-level version of the first function, starting from PeriodicFacePairs.  <a href="#a02ccc2d5be9d7550b75fa196aeb71656"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename DH &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenatrium_1_1DealIIExtensions.html#a01f414566020f59f29036fd7e22341b9">make_periodicity_map_dg</a> (const DH &amp;dof_handler, size_t b_id1, size_t b_id2, const int direction, PeriodicCellMap&lt; DH::dimension &gt; &amp;cell_map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Another high-level version of the first function, starting from boundary indicators.  <a href="#a01f414566020f59f29036fd7e22341b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenatrium_1_1DealIIExtensions.html#ad74bfc63a45e2d4c1c9f2dd625cf1a66">extract_dofs_with_support_on_boundary</a> (const DH &amp;dof_handler, const ComponentMask &amp;component_mask, std::vector&lt; bool &gt; &amp;selected_dofs, const std::set&lt; types::boundary_id &gt; &amp;boundary_ids)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function extracts those degrees of freedom whose shape functions are nonzero on at least part of the selected boundary. For continuous elements, this is exactly the set of shape functions whose degrees of freedom are defined on boundary faces. On the other hand, if the finite element in used is a discontinuous element, all degrees of freedom are defined in the inside of cells and consequently none would be boundary degrees of freedom. Several of those would have shape functions that are nonzero on the boundary, however. This function therefore extracts all those for which the FiniteElement::has_support_on_face function says that it is nonzero on any face on one of the selected boundary parts.  <a href="#ad74bfc63a45e2d4c1c9f2dd625cf1a66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1114fe047dc504c301fade5677bcea1d"></a><!-- doxytag: member="natrium::DealIIExtensions::make_sparser_flux_sparsity_pattern&lt; DoFHandler&lt; 2 &gt;, SP &gt;" ref="a1114fe047dc504c301fade5677bcea1d" args="(const DoFHandler&lt; 2 &gt; &amp;dof, SP &amp;sparsity, const BoundaryCollection&lt; 2 &gt; &amp;boundaries, FEFaceValues&lt; 2 &gt; *fe_face)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_sparser_flux_sparsity_pattern&lt; DoFHandler&lt; 2 &gt;, SP &gt;</b> (const DoFHandler&lt; 2 &gt; &amp;dof, SP &amp;sparsity, const <a class="el" href="classnatrium_1_1BoundaryCollection.html">BoundaryCollection</a>&lt; 2 &gt; &amp;boundaries, FEFaceValues&lt; 2 &gt; *fe_face)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f6065aca54041aa9bd6ca3733478988"></a><!-- doxytag: member="natrium::DealIIExtensions::make_sparser_flux_sparsity_pattern&lt; DoFHandler&lt; 2 &gt;, SP &gt;" ref="a9f6065aca54041aa9bd6ca3733478988" args="(const DoFHandler&lt; 2 &gt; &amp;dof, SP &amp;sparsity, const ConstraintMatrix &amp;constraints, const BoundaryCollection&lt; 2 &gt; &amp;boundaries, FEFaceValues&lt; 2 &gt; *fe_face, const bool, const unsigned int)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_sparser_flux_sparsity_pattern&lt; DoFHandler&lt; 2 &gt;, SP &gt;</b> (const DoFHandler&lt; 2 &gt; &amp;dof, SP &amp;sparsity, const ConstraintMatrix &amp;constraints, const <a class="el" href="classnatrium_1_1BoundaryCollection.html">BoundaryCollection</a>&lt; 2 &gt; &amp;boundaries, FEFaceValues&lt; 2 &gt; *fe_face, const bool, const unsigned int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33884e02520bb06cf29f3be01a2d7b42"></a><!-- doxytag: member="natrium::DealIIExtensions::make_sparser_flux_sparsity_pattern&lt; DoFHandler&lt; 3 &gt;, SP &gt;" ref="a33884e02520bb06cf29f3be01a2d7b42" args="(const DoFHandler&lt; 3 &gt; &amp;dof, SP &amp;sparsity, const BoundaryCollection&lt; 3 &gt; &amp;boundaries, FEFaceValues&lt; 3 &gt; *fe_face)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_sparser_flux_sparsity_pattern&lt; DoFHandler&lt; 3 &gt;, SP &gt;</b> (const DoFHandler&lt; 3 &gt; &amp;dof, SP &amp;sparsity, const <a class="el" href="classnatrium_1_1BoundaryCollection.html">BoundaryCollection</a>&lt; 3 &gt; &amp;boundaries, FEFaceValues&lt; 3 &gt; *fe_face)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bfd0edfcc602aa68f3e5e627a5f1e8b"></a><!-- doxytag: member="natrium::DealIIExtensions::make_sparser_flux_sparsity_pattern&lt; DoFHandler&lt; 3 &gt;, SP &gt;" ref="a6bfd0edfcc602aa68f3e5e627a5f1e8b" args="(const DoFHandler&lt; 3 &gt; &amp;dof, SP &amp;sparsity, const ConstraintMatrix &amp;constraints, const BoundaryCollection&lt; 3 &gt; &amp;boundaries, FEFaceValues&lt; 3 &gt; *fe_face, const bool, const unsigned int)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_sparser_flux_sparsity_pattern&lt; DoFHandler&lt; 3 &gt;, SP &gt;</b> (const DoFHandler&lt; 3 &gt; &amp;dof, SP &amp;sparsity, const ConstraintMatrix &amp;constraints, const <a class="el" href="classnatrium_1_1BoundaryCollection.html">BoundaryCollection</a>&lt; 3 &gt; &amp;boundaries, FEFaceValues&lt; 3 &gt; *fe_face, const bool, const unsigned int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec93b076a99e59c28b7921e26d81b450"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg&lt; DoFHandler&lt; 2 &gt; &gt;" ref="aec93b076a99e59c28b7921e26d81b450" args="(const typename DoFHandler&lt; 2 &gt;::cell_iterator &amp;cell_1, const identity&lt; typename DoFHandler&lt; 2 &gt;::cell_iterator &gt;::type &amp;cell_2, size_t face_nr_1, size_t face_nr_2, PeriodicCellMap&lt; 2 &gt; &amp;cell_map, const bool face_orientation, const bool face_flip, const bool face_rotation)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_periodicity_map_dg&lt; DoFHandler&lt; 2 &gt; &gt;</b> (const typename DoFHandler&lt; 2 &gt;::cell_iterator &amp;cell_1, const identity&lt; typename DoFHandler&lt; 2 &gt;::cell_iterator &gt;::type &amp;cell_2, size_t face_nr_1, size_t face_nr_2, PeriodicCellMap&lt; 2 &gt; &amp;cell_map, const bool face_orientation, const bool face_flip, const bool face_rotation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff90e32d1a427e62cb287350abe90ba0"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg&lt; DoFHandler&lt; 3 &gt; &gt;" ref="aff90e32d1a427e62cb287350abe90ba0" args="(const typename DoFHandler&lt; 3 &gt;::cell_iterator &amp;cell_1, const identity&lt; typename DoFHandler&lt; 3 &gt;::cell_iterator &gt;::type &amp;cell_2, size_t face_nr_1, size_t face_nr_2, PeriodicCellMap&lt; 3 &gt; &amp;cell_map, const bool face_orientation, const bool face_flip, const bool face_rotation)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_periodicity_map_dg&lt; DoFHandler&lt; 3 &gt; &gt;</b> (const typename DoFHandler&lt; 3 &gt;::cell_iterator &amp;cell_1, const identity&lt; typename DoFHandler&lt; 3 &gt;::cell_iterator &gt;::type &amp;cell_2, size_t face_nr_1, size_t face_nr_2, PeriodicCellMap&lt; 3 &gt; &amp;cell_map, const bool face_orientation, const bool face_flip, const bool face_rotation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7db4d0d0c8236483eb98b0f09e79b89"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg&lt; DoFHandler&lt; 2 &gt; &gt;" ref="aa7db4d0d0c8236483eb98b0f09e79b89" args="(const std::vector&lt; GridTools::PeriodicFacePair&lt; typename DoFHandler&lt; 2 &gt;::cell_iterator &gt; &gt; &amp;periodic_faces, PeriodicCellMap&lt; 2 &gt; &amp;cell_map)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_periodicity_map_dg&lt; DoFHandler&lt; 2 &gt; &gt;</b> (const std::vector&lt; GridTools::PeriodicFacePair&lt; typename DoFHandler&lt; 2 &gt;::cell_iterator &gt; &gt; &amp;periodic_faces, PeriodicCellMap&lt; 2 &gt; &amp;cell_map)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9da850ee914812ca5d374fe70461f170"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg&lt; DoFHandler&lt; 3 &gt; &gt;" ref="a9da850ee914812ca5d374fe70461f170" args="(const std::vector&lt; GridTools::PeriodicFacePair&lt; typename DoFHandler&lt; 3 &gt;::cell_iterator &gt; &gt; &amp;periodic_faces, PeriodicCellMap&lt; 3 &gt; &amp;cell_map)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_periodicity_map_dg&lt; DoFHandler&lt; 3 &gt; &gt;</b> (const std::vector&lt; GridTools::PeriodicFacePair&lt; typename DoFHandler&lt; 3 &gt;::cell_iterator &gt; &gt; &amp;periodic_faces, PeriodicCellMap&lt; 3 &gt; &amp;cell_map)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae31f8793dc208deb99e34201a9c17779"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg&lt; DoFHandler&lt; 2 &gt; &gt;" ref="ae31f8793dc208deb99e34201a9c17779" args="(const DoFHandler&lt; 2 &gt; &amp;dof_handler, size_t b_id1, size_t b_id2, const int direction, PeriodicCellMap&lt; 2 &gt; &amp;cell_map)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_periodicity_map_dg&lt; DoFHandler&lt; 2 &gt; &gt;</b> (const DoFHandler&lt; 2 &gt; &amp;dof_handler, size_t b_id1, size_t b_id2, const int direction, PeriodicCellMap&lt; 2 &gt; &amp;cell_map)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d4a08bca6d3ef3833ba3a0107ea7fa8"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg&lt; DoFHandler&lt; 3 &gt; &gt;" ref="a4d4a08bca6d3ef3833ba3a0107ea7fa8" args="(const DoFHandler&lt; 3 &gt; &amp;dof_handler, size_t b_id1, size_t b_id2, const int direction, PeriodicCellMap&lt; 3 &gt; &amp;cell_map)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_periodicity_map_dg&lt; DoFHandler&lt; 3 &gt; &gt;</b> (const DoFHandler&lt; 3 &gt; &amp;dof_handler, size_t b_id1, size_t b_id2, const int direction, PeriodicCellMap&lt; 3 &gt; &amp;cell_map)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae531bdf7ab145d71f306ec1d4a1cefb3"></a><!-- doxytag: member="natrium::DealIIExtensions::extract_dofs_with_support_on_boundary" ref="ae531bdf7ab145d71f306ec1d4a1cefb3" args="(const dealii::DoFHandler&lt; 2 &gt; &amp;dof_handler, const ComponentMask &amp;component_mask, std::vector&lt; bool &gt; &amp;selected_dofs, const std::set&lt; types::boundary_id &gt; &amp;boundary_ids)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_dofs_with_support_on_boundary</b> (const dealii::DoFHandler&lt; 2 &gt; &amp;dof_handler, const ComponentMask &amp;component_mask, std::vector&lt; bool &gt; &amp;selected_dofs, const std::set&lt; types::boundary_id &gt; &amp;boundary_ids)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a157762b4a7d95c0f6b614f451d1dbd2d"></a><!-- doxytag: member="natrium::DealIIExtensions::extract_dofs_with_support_on_boundary" ref="a157762b4a7d95c0f6b614f451d1dbd2d" args="(const dealii::DoFHandler&lt; 3 &gt; &amp;dof_handler, const ComponentMask &amp;component_mask, std::vector&lt; bool &gt; &amp;selected_dofs, const std::set&lt; types::boundary_id &gt; &amp;boundary_ids)" -->
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_dofs_with_support_on_boundary</b> (const dealii::DoFHandler&lt; 3 &gt; &amp;dof_handler, const ComponentMask &amp;component_mask, std::vector&lt; bool &gt; &amp;selected_dofs, const std::set&lt; types::boundary_id &gt; &amp;boundary_ids)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>some extensions to deal.ii </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad74bfc63a45e2d4c1c9f2dd625cf1a66"></a><!-- doxytag: member="natrium::DealIIExtensions::extract_dofs_with_support_on_boundary" ref="ad74bfc63a45e2d4c1c9f2dd625cf1a66" args="(const DH &amp;dof_handler, const ComponentMask &amp;component_mask, std::vector&lt; bool &gt; &amp;selected_dofs, const std::set&lt; types::boundary_id &gt; &amp;boundary_ids)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void natrium::DealIIExtensions::extract_dofs_with_support_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&nbsp;</td>
          <td class="paramname"> <em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ComponentMask &amp;&nbsp;</td>
          <td class="paramname"> <em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; types::boundary_id &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary_ids</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function extracts those degrees of freedom whose shape functions are nonzero on at least part of the selected boundary. For continuous elements, this is exactly the set of shape functions whose degrees of freedom are defined on boundary faces. On the other hand, if the finite element in used is a discontinuous element, all degrees of freedom are defined in the inside of cells and consequently none would be boundary degrees of freedom. Several of those would have shape functions that are nonzero on the boundary, however. This function therefore extracts all those for which the FiniteElement::has_support_on_face function says that it is nonzero on any face on one of the selected boundary parts. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is the same as the deal.ii function with the same name; except for one line which restricts the function to the locally owned cells. </dd></dl>

</div>
</div>
<a class="anchor" id="a01f414566020f59f29036fd7e22341b9"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg" ref="a01f414566020f59f29036fd7e22341b9" args="(const DH &amp;dof_handler, size_t b_id1, size_t b_id2, const int direction, PeriodicCellMap&lt; DH::dimension &gt; &amp;cell_map)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void natrium::DealIIExtensions::make_periodicity_map_dg </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&nbsp;</td>
          <td class="paramname"> <em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PeriodicCellMap&lt; DH::dimension &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cell_map</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Another high-level version of the first function, starting from boundary indicators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dof_handler</em>&nbsp;</td><td>a DoFHandler object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b_id1</em>&nbsp;</td><td>boundary id at the first side of the periodic boundary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b_id2</em>&nbsp;</td><td>boundary id at the second side of the periodic boundary </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>cell_map</em>&nbsp;</td><td>A map that stores cells and faces at the periodic boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Creating periodic boundaries requires great care in the order of operations (at least for Meshes of type parallel::distributed::Triangulation&lt;dim&gt;)<ol type="1">
<li>create unrefined mesh</li>
<li>call collect_periodic_faces&lt;Mesh&gt; to find out the periodic couplings at the coarsest level</li>
<li>call add_periodicity to create a layer of ghost nodes across the periodic boundary</li>
<li>call this function (make_periodicity_map_dg) to recursively find out the periodic couplings on the active levels </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="a02ccc2d5be9d7550b75fa196aeb71656"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg" ref="a02ccc2d5be9d7550b75fa196aeb71656" args="(const std::vector&lt; GridTools::PeriodicFacePair&lt; typename DH::cell_iterator &gt; &gt; &amp;periodic_faces, PeriodicCellMap&lt; DH::dimension &gt; &amp;cell_map)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void natrium::DealIIExtensions::make_periodicity_map_dg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; GridTools::PeriodicFacePair&lt; typename DH::cell_iterator &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PeriodicCellMap&lt; DH::dimension &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cell_map</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>High-level version of the first function, starting from PeriodicFacePairs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>periodic_faces</em>&nbsp;</td><td>a vector of PeriodicFacePairs. They can be obtained by calling collect_periodic_faces. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>cell_map</em>&nbsp;</td><td>A map that stores cells and faces at the periodic boundary </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bc5b9999ee7c47791ea8754f586277e"></a><!-- doxytag: member="natrium::DealIIExtensions::make_periodicity_map_dg" ref="a6bc5b9999ee7c47791ea8754f586277e" args="(const typename DH::cell_iterator &amp;cell_1, const typename identity&lt; typename DH::cell_iterator &gt;::type &amp;cell_2, size_t face_nr_1, size_t face_nr_2, PeriodicCellMap&lt; DH::dimension &gt; &amp;cell_map, const bool face_orientation, const bool face_flip, const bool face_rotation)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void natrium::DealIIExtensions::make_periodicity_map_dg </td>
          <td>(</td>
          <td class="paramtype">const typename DH::cell_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>cell_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename identity&lt; typename DH::cell_iterator &gt;::type &amp;&nbsp;</td>
          <td class="paramname"> <em>cell_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>face_nr_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>face_nr_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PeriodicCellMap&lt; DH::dimension &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cell_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>face_rotation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gathers cell pairs at a periodic boundary. This function starts at the coarsest level and recursively visits the subcells of boundary cells. At the active level, cell pairs are added to the cell_map. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cell_1</em>&nbsp;</td><td>cell at the one side of a periodic boundary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cell_2</em>&nbsp;</td><td>cell at the other side of a periodic boundary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>face_nr_1</em>&nbsp;</td><td>boundary face number of the cell_1 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>face_nr_2</em>&nbsp;</td><td>boundary face number of the cell_2 </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>cell_map</em>&nbsp;</td><td>A map that stores cells and faces at the periodic boundary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>face_orientation</em>&nbsp;</td><td>see deal.ii Glossary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>face_flip</em>&nbsp;</td><td>see deal.ii Glossary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>face_rotation</em>&nbsp;</td><td>see deal.ii Glossary </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The implementation of this function is similar to dealii::make_periodicity_constraints </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 9 Dec 2015 for NATriuM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
