\hypertarget{classnatrium_1_1SemiLagrangian}{
\section{natrium::SemiLagrangian$<$ dim $>$ Class Template Reference}
\label{classnatrium_1_1SemiLagrangian}\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}}
}


This class solves the linear advection equations by a semi-\/Lagrangian scheme.  


{\ttfamily \#include $<$SemiLagrangian.h$>$}Inheritance diagram for natrium::SemiLagrangian$<$ dim $>$::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classnatrium_1_1SemiLagrangian}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classnatrium_1_1SemiLagrangian_a6875a404457277b3e1f7853768837b3f}{SemiLagrangian} (\hyperlink{classnatrium_1_1ProblemDescription}{ProblemDescription}$<$ dim $>$ \&problem, size\_\-t orderOfFiniteElement, QuadratureName quad\_\-name, SupportPointsName points\_\-name, boost::shared\_\-ptr$<$ \hyperlink{classnatrium_1_1Stencil}{Stencil} $>$ stencil, double delta\_\-t)
\begin{DoxyCompactList}\small\item\em constructor \item\end{DoxyCompactList}\item 
\hypertarget{classnatrium_1_1SemiLagrangian_a4b94451652c87b98a140ddcec7f21033}{
{\bfseries SemiLagrangian} (\hyperlink{classnatrium_1_1ProblemDescription}{ProblemDescription}$<$ dim $>$ \&problem, size\_\-t orderOfFiniteElement, boost::shared\_\-ptr$<$ \hyperlink{classnatrium_1_1Stencil}{Stencil} $>$ stencil, double delta\_\-t)}
\label{classnatrium_1_1SemiLagrangian_a4b94451652c87b98a140ddcec7f21033}

\item 
\hypertarget{classnatrium_1_1SemiLagrangian_a6c0ebcd2055e6608cc6f280a89ea43a3}{
virtual \hyperlink{classnatrium_1_1SemiLagrangian_a6c0ebcd2055e6608cc6f280a89ea43a3}{$\sim$SemiLagrangian} ()}
\label{classnatrium_1_1SemiLagrangian_a6c0ebcd2055e6608cc6f280a89ea43a3}

\begin{DoxyCompactList}\small\item\em destructor \item\end{DoxyCompactList}\item 
int \hyperlink{classnatrium_1_1SemiLagrangian_a3b096afb85f7ea3782e03ba36b973088}{faceCrossedFirst} (const typename dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \&cell, const dealii::Point$<$ dim $>$ \&p\_\-inside, const dealii::Point$<$ dim $>$ \&p\_\-outside, dealii::Point$<$ dim $>$ \&p\_\-boundary, double $\ast$lambda, size\_\-t $\ast$child\_\-id)
\begin{DoxyCompactList}\small\item\em Determines which face is crossed first, when moving from one point inside the cell to a point outside. \item\end{DoxyCompactList}\item 
\hypertarget{classnatrium_1_1SemiLagrangian_a7f08b1181db3c1d1f26ba0cac9210fbc}{
virtual void \hyperlink{classnatrium_1_1SemiLagrangian_a7f08b1181db3c1d1f26ba0cac9210fbc}{reassemble} ()}
\label{classnatrium_1_1SemiLagrangian_a7f08b1181db3c1d1f26ba0cac9210fbc}

\begin{DoxyCompactList}\small\item\em function to (re-\/)assemble linear system \item\end{DoxyCompactList}\item 
\hypertarget{classnatrium_1_1SemiLagrangian_a29408988807e9fbe24c8900c0e6bcf00}{
virtual void \hyperlink{classnatrium_1_1SemiLagrangian_a29408988807e9fbe24c8900c0e6bcf00}{setupDoFs} ()}
\label{classnatrium_1_1SemiLagrangian_a29408988807e9fbe24c8900c0e6bcf00}

\begin{DoxyCompactList}\small\item\em Setup degrees of freedom and fill sparsity pattern of the system matrix. Purely virtual for this class. \item\end{DoxyCompactList}\item 
virtual double \hyperlink{classnatrium_1_1SemiLagrangian_a03956c49c0bd288340b734f2fa9aad3c}{stream} (\hyperlink{classnatrium_1_1DistributionFunctions}{DistributionFunctions} \&f\_\-old, \hyperlink{classnatrium_1_1DistributionFunctions}{DistributionFunctions} \&f, double t)
\begin{DoxyCompactList}\small\item\em Stream the distribution functions. Purely virtual for this class. \item\end{DoxyCompactList}\item 
\hypertarget{classnatrium_1_1SemiLagrangian_a731b3834c039ba6bc07a5ee0e51f8e4c}{
virtual void {\bfseries applyBoundaryConditions} (\hyperlink{classnatrium_1_1DistributionFunctions}{DistributionFunctions} \&f\_\-old, \hyperlink{classnatrium_1_1DistributionFunctions}{DistributionFunctions} \&f, double t)}
\label{classnatrium_1_1SemiLagrangian_a731b3834c039ba6bc07a5ee0e51f8e4c}

\item 
virtual void \hyperlink{classnatrium_1_1SemiLagrangian_abd17b628b89c43303d067c0a4e4d0bf1}{setDeltaT} (double deltaT)
\begin{DoxyCompactList}\small\item\em set time step \item\end{DoxyCompactList}\item 
dealii::DoFHandler$<$ dim $>$::cell\_\-iterator \hyperlink{classnatrium_1_1SemiLagrangian_a5e70ea981e2070d5e9657f3df8d61979}{getNeighbor} (const typename dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \&cell, size\_\-t i)
\begin{DoxyCompactList}\small\item\em get i-\/th neighbor of a cell, incorporating periodic boundaries \item\end{DoxyCompactList}\item 
void \hyperlink{classnatrium_1_1SemiLagrangian_a511a39fcd3f598bd42c18deeb50cd7f5}{getNeighborhood} (typename dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \&cell, Neighborhood$<$ dim $>$ \&neighborhood, size\_\-t n\_\-shells=1)
\begin{DoxyCompactList}\small\item\em fill the neighborhood list \item\end{DoxyCompactList}\item 
dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \hyperlink{classnatrium_1_1SemiLagrangian_a8d075c2ae01b26d66999782cc14c5515}{recursivelySearchInNeighborhood} (const dealii::Point$<$ dim $>$ \&p, typename dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \&cell)
\begin{DoxyCompactList}\small\item\em recursively search a point in neighborhood, until is found \item\end{DoxyCompactList}\item 
virtual void \hyperlink{classnatrium_1_1SemiLagrangian_ac11ac59a28176a74e94fde81362ce7b5}{setTimeIntegrator} (boost::shared\_\-ptr$<$ \hyperlink{classnatrium_1_1TimeIntegrator}{TimeIntegrator}$<$ distributed\_\-sparse\_\-block\_\-matrix, distributed\_\-block\_\-vector $>$ $>$)
\begin{DoxyCompactList}\small\item\em Apply boundary conditions. Purely virtual for this class. \item\end{DoxyCompactList}\item 
\hypertarget{classnatrium_1_1SemiLagrangian_ac644f8378ee6bd26ff24eb025a60dda0}{
const \hyperlink{classnatrium_1_1SemiLagrangianBoundaryHandler}{SemiLagrangianBoundaryHandler}$<$ dim $>$ \& {\bfseries getBoundaryHandler} () const }
\label{classnatrium_1_1SemiLagrangian_ac644f8378ee6bd26ff24eb025a60dda0}

\item 
bool \hyperlink{classnatrium_1_1SemiLagrangian_a7facbe9874541441921973030ec6f831}{isCellInNeighborhood} (const typename dealii::DoFHandler$<$ dim $>$::cell\_\-accessor \&cell, const Neighborhood$<$ dim $>$ \&neighborhood)
\begin{DoxyCompactList}\small\item\em Checks if a cell is already in the neighborhood list. \item\end{DoxyCompactList}\item 
\hypertarget{classnatrium_1_1SemiLagrangian_a6cdea22c2d1999275488710ab08c94fa}{
const std::vector$<$ std::vector$<$ dealii::TrilinosWrappers::SparsityPattern $>$ $>$ \& {\bfseries getBlockSparsityPattern} () const }
\label{classnatrium_1_1SemiLagrangian_a6cdea22c2d1999275488710ab08c94fa}

\item 
\hypertarget{classnatrium_1_1SemiLagrangian_ac447ccd4c5b945da503cd57f8072db81}{
virtual size\_\-t \hyperlink{classnatrium_1_1SemiLagrangian_ac447ccd4c5b945da503cd57f8072db81}{memory\_\-consumption\_\-sparsity\_\-pattern} () const }
\label{classnatrium_1_1SemiLagrangian_ac447ccd4c5b945da503cd57f8072db81}

\begin{DoxyCompactList}\small\item\em estimate the memory consumption of the sparsity pattern For SEDG, this is 0, because the sparsity pattern is a part of the trilinos matrix. \item\end{DoxyCompactList}\item 
\hypertarget{classnatrium_1_1SemiLagrangian_a730b721bc86a64418b2ae60fa888b3d4}{
virtual const distributed\_\-block\_\-vector \& \hyperlink{classnatrium_1_1SemiLagrangian_a730b721bc86a64418b2ae60fa888b3d4}{getSystemVector} () const }
\label{classnatrium_1_1SemiLagrangian_a730b721bc86a64418b2ae60fa888b3d4}

\begin{DoxyCompactList}\small\item\em get system vector. To be removed. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$size\_\-t dim$>$ class natrium::SemiLagrangian$<$ dim $>$}

This class solves the linear advection equations by a semi-\/Lagrangian scheme. 
\begin{DoxyTemplParams}{Template Parameters}
\item[{\em dim}]The dimension of the flow (2 or 3). \end{DoxyTemplParams}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classnatrium_1_1SemiLagrangian_a6875a404457277b3e1f7853768837b3f}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!SemiLagrangian@{SemiLagrangian}}
\index{SemiLagrangian@{SemiLagrangian}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{SemiLagrangian}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ {\bf natrium::SemiLagrangian}$<$ dim $>$::{\bf SemiLagrangian} ({\bf ProblemDescription}$<$ dim $>$ \& {\em problem}, \/  size\_\-t {\em orderOfFiniteElement}, \/  QuadratureName {\em quad\_\-name}, \/  SupportPointsName {\em points\_\-name}, \/  boost::shared\_\-ptr$<$ {\bf Stencil} $>$ {\em stencil}, \/  double {\em delta\_\-t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_a6875a404457277b3e1f7853768837b3f}


constructor Constructor 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em triangulation}]The global mesh. \item[\mbox{$\leftarrow$} {\em orderOfFiniteElement}]The number of nodes element and dimension \item[\mbox{$\leftarrow$} {\em stencil}]the DQ model \item[\mbox{$\leftarrow$} {\em delta\_\-t}]time step size; if delta\_\-t = 0, the sparsity pattern is not updated during construction \end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{classnatrium_1_1SemiLagrangian_a3b096afb85f7ea3782e03ba36b973088}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!faceCrossedFirst@{faceCrossedFirst}}
\index{faceCrossedFirst@{faceCrossedFirst}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{faceCrossedFirst}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ int {\bf natrium::SemiLagrangian}$<$ dim $>$::faceCrossedFirst (const typename dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \& {\em cell}, \/  const dealii::Point$<$ dim $>$ \& {\em p\_\-inside}, \/  const dealii::Point$<$ dim $>$ \& {\em p\_\-outside}, \/  dealii::Point$<$ dim $>$ \& {\em p\_\-boundary}, \/  double $\ast$ {\em lambda}, \/  size\_\-t $\ast$ {\em child\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_a3b096afb85f7ea3782e03ba36b973088}


Determines which face is crossed first, when moving from one point inside the cell to a point outside. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em cell}]iterator to the active cell that contains the point p\_\-inside \item[\mbox{$\leftarrow$} {\em p\_\-inside}]the point inside the cell \item[\mbox{$\leftarrow$} {\em p\_\-outside}]the point outside the cell \item[\mbox{$\rightarrow$} {\em p\_\-boundary}]the point where the boundary is hit \item[\mbox{$\rightarrow$} {\em lambda}]the parameter lambda that solves p\_\-boundary\_\-unit = lambda $\ast$ p\_\-outside\_\-unit + (1-\/lambda) $\ast$ p\_\-inside\_\-unit \end{DoxyParams}
\begin{DoxyReturn}{Returns}
face\_\-id, if a face is crossed; -\/1, if no face is crossed (i.e. the second point is inside the cell) 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
lambda is calculated for the unit cell. In general, p\_\-boundary = lambda $\ast$ p\_\-outside + (1-\/lambda) $\ast$ p\_\-inside does not hold 

The current implementation does not do anything special at corner nodes. It prefers x over y over z faces. This may lead to problems later on. 
\end{DoxyNote}
\hypertarget{classnatrium_1_1SemiLagrangian_a5e70ea981e2070d5e9657f3df8d61979}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!getNeighbor@{getNeighbor}}
\index{getNeighbor@{getNeighbor}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{getNeighbor}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ dealii::DoFHandler$<$ dim $>$::cell\_\-iterator {\bf natrium::SemiLagrangian}$<$ dim $>$::getNeighbor (const typename dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \& {\em cell}, \/  size\_\-t {\em i})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_a5e70ea981e2070d5e9657f3df8d61979}


get i-\/th neighbor of a cell, incorporating periodic boundaries 
\begin{DoxyParams}{Parameters}
\item[{\em cell}]An iterator pointing to cell \item[{\em i}]face index (=neighbor index) \end{DoxyParams}
\begin{DoxyReturn}{Returns}
m\_\-doFHandler-\/$>$end(), if cell has no i-\/th neighbor (e.g. at solid boundary) 
\end{DoxyReturn}
\hypertarget{classnatrium_1_1SemiLagrangian_a511a39fcd3f598bd42c18deeb50cd7f5}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!getNeighborhood@{getNeighborhood}}
\index{getNeighborhood@{getNeighborhood}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{getNeighborhood}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ void {\bf natrium::SemiLagrangian}$<$ dim $>$::getNeighborhood (typename dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \& {\em cell}, \/  Neighborhood$<$ dim $>$ \& {\em neighborhood}, \/  size\_\-t {\em n\_\-shells} = {\ttfamily 1})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_a511a39fcd3f598bd42c18deeb50cd7f5}


fill the neighborhood list 
\begin{DoxyParams}{Parameters}
\item[{\em cell}]cell \item[{\em neighborhood}]the neighborhood object \end{DoxyParams}
\begin{DoxyNote}{Note}
the neighborhood incorporates the current cell, all its neighbors, and their respective neighbors; each cell has only pointer to it in the neighborhood. 
\end{DoxyNote}
\hypertarget{classnatrium_1_1SemiLagrangian_a7facbe9874541441921973030ec6f831}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!isCellInNeighborhood@{isCellInNeighborhood}}
\index{isCellInNeighborhood@{isCellInNeighborhood}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{isCellInNeighborhood}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ bool {\bf natrium::SemiLagrangian}$<$ dim $>$::isCellInNeighborhood (const typename dealii::DoFHandler$<$ dim $>$::cell\_\-accessor \& {\em cell}, \/  const Neighborhood$<$ dim $>$ \& {\em neighborhood})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_a7facbe9874541441921973030ec6f831}


Checks if a cell is already in the neighborhood list. 
\begin{DoxyParams}{Parameters}
\item[{\em cell}]the cell \item[{\em neighborhood}]the neighborhood list \end{DoxyParams}
\begin{DoxyReturn}{Returns}
true, if cell is already in the list 
\end{DoxyReturn}
\hypertarget{classnatrium_1_1SemiLagrangian_a8d075c2ae01b26d66999782cc14c5515}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!recursivelySearchInNeighborhood@{recursivelySearchInNeighborhood}}
\index{recursivelySearchInNeighborhood@{recursivelySearchInNeighborhood}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{recursivelySearchInNeighborhood}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator {\bf natrium::SemiLagrangian}$<$ dim $>$::recursivelySearchInNeighborhood (const dealii::Point$<$ dim $>$ \& {\em p}, \/  typename dealii::DoFHandler$<$ dim $>$::active\_\-cell\_\-iterator \& {\em cell})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_a8d075c2ae01b26d66999782cc14c5515}


recursively search a point in neighborhood, until is found 
\begin{DoxyParams}{Parameters}
\item[{\em p}]the point you search for \item[{\em cell}]The start cell of the recursive search \end{DoxyParams}
\begin{DoxyReturn}{Returns}
A cell that contains the point p. If the point was not found, the cell pointer will point to DoFHandler.end() 
\end{DoxyReturn}
\hypertarget{classnatrium_1_1SemiLagrangian_abd17b628b89c43303d067c0a4e4d0bf1}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!setDeltaT@{setDeltaT}}
\index{setDeltaT@{setDeltaT}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{setDeltaT}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ virtual void {\bf natrium::SemiLagrangian}$<$ dim $>$::setDeltaT (double {\em delta\_\-t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_abd17b628b89c43303d067c0a4e4d0bf1}


set time step 
\begin{DoxyParams}{Parameters}
\item[{\em delta\_\-t}]time step \end{DoxyParams}


Reimplemented from \hyperlink{classnatrium_1_1AdvectionOperator_a640db5be4d4930198124fa57752167e5}{natrium::AdvectionOperator$<$ dim $>$}.\hypertarget{classnatrium_1_1SemiLagrangian_ac11ac59a28176a74e94fde81362ce7b5}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!setTimeIntegrator@{setTimeIntegrator}}
\index{setTimeIntegrator@{setTimeIntegrator}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{setTimeIntegrator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ virtual void {\bf natrium::SemiLagrangian}$<$ dim $>$::setTimeIntegrator (boost::shared\_\-ptr$<$ {\bf TimeIntegrator}$<$ distributed\_\-sparse\_\-block\_\-matrix, distributed\_\-block\_\-vector $>$ $>$ {\em timeIntegrator})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_ac11ac59a28176a74e94fde81362ce7b5}


Apply boundary conditions. Purely virtual for this class. \begin{DoxyNote}{Note}
While the SEDG boundary conditions are directly implemented in the system matrix and vector, the semi-\/Lagrangian advection operator needs to do something in this functions. set the time integrator for the SEDG streaming step. Purely virtual for this class. 

This function is empty for the semi-\/Lagrangian streaming, which does not require time integrators. 
\end{DoxyNote}


Implements \hyperlink{classnatrium_1_1AdvectionOperator_aa93f60c7e7270a35df21387a962d7a38}{natrium::AdvectionOperator$<$ dim $>$}.\hypertarget{classnatrium_1_1SemiLagrangian_a03956c49c0bd288340b734f2fa9aad3c}{
\index{natrium::SemiLagrangian@{natrium::SemiLagrangian}!stream@{stream}}
\index{stream@{stream}!natrium::SemiLagrangian@{natrium::SemiLagrangian}}
\subsubsection[{stream}]{\setlength{\rightskip}{0pt plus 5cm}template$<$size\_\-t dim$>$ virtual double {\bf natrium::SemiLagrangian}$<$ dim $>$::stream ({\bf DistributionFunctions} \& {\em f\_\-old}, \/  {\bf DistributionFunctions} \& {\em f}, \/  double {\em t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classnatrium_1_1SemiLagrangian_a03956c49c0bd288340b734f2fa9aad3c}


Stream the distribution functions. Purely virtual for this class. 
\begin{DoxyParams}{Parameters}
\item[{\em f\_\-old}]distribution functions at t \item[{\em f}]distribution functsion at t+delta\_\-t \end{DoxyParams}


Implements \hyperlink{classnatrium_1_1AdvectionOperator_abccc060e37071fa776cd6e9fc6cc7987}{natrium::AdvectionOperator$<$ dim $>$}.

The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/mnt/fdrive/akraem3m/workspace/NATriuM/src/library/natrium/advection/\hyperlink{SemiLagrangian_8h}{SemiLagrangian.h}\item 
/mnt/fdrive/akraem3m/workspace/NATriuM/src/library/natrium/advection/\hyperlink{SemiLagrangian_8cpp}{SemiLagrangian.cpp}\end{DoxyCompactItemize}
